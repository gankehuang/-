# 前端知识点汇总

### ES6
> 列举常用es6特性：
- 申明变量let和const
- 可在传递参数除指定默认值
- 箭头函数写法更加简洁，省略了function关键字申明，省略return
- 模板字符串
- Promise链式调用
- 增加了class关键字来定义声明一个类，还多了extends继承关键字
- export导出模块、import导入模块
- 解构赋值 [react-redux]() 状态管理库;用redux-logger打印日志，方便调试;用redux-thunk实现异步操作
> let, const, var 的区别
- var声明的变量会挂载在window上，而let和const声明的变量不会
- var声明变量存在变量提升，let和const不存在变量提升
- let和const声明形成块作用域
- 同一作用域下let和const不能声明同名变量，而var可以
>es6箭头函数的this
- 箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象
>promise的状态、链式调用、同步异步流程、唯一性
- promise俗称链式调用，它是es6中最重要的特性之一，简单的说可以不停的then调用嵌套在调用（异步之后，链式调用方式执行回调），这种操作方式称为promise
- 包含两个参数： Resolve：将promise的状态设置为完成状态（resolved），此时then方法捕捉变化，执行成功的回调
    Reject：将promise状态设置为无效，（rejected），此时then方法执行失败回调
- Promise之All，等执行所有异步，完事之后执行then回调返回出数组数据类型
>set去重
- ES6中新增了Set数据结构，类似于数组，但是 它的成员都是唯一的 ，其构造函数可以接受一个数组作为参数
- ES6中Array新增了一个静态方法Array.from，可以把类似数组的对象转换为数组
>js数组去重
- 最简单的数组去重方法（indexOf方法）:新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中(indexOf返回当前元素下标，没找到返回-1)
- 优化遍历数组法（推荐）: 双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length,将没重复的右边值放入新数组


### js基础
>闭包
- 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
- 换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来
- 闭包外部函数能够读取内部函数的变量
- 优点：闭包可以形成独立的空间，永久的保存局部变量。
- 缺点：保存中间值的状态缺点是容易造成内存泄漏，因为闭包中的局部变量永远不会被回收
>作用域
- 任何编程语言都有作用域的概念，简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。
- 全部作用域：任何地方都能访问到的对象拥有全局作用域
- 局部作用域：局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以在一些地方会把这种作用域成为函数作用域
- ES6的块级作用域: 明确允许在块级作用域中声明函数，let和const命令都涉及块级作用域。
- 作用域链: 当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链, 当执行函数时，总是先从函数内部找寻局部变量，如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上
>字符串操作方法
- charAt(1)   返回给定位置的那个字符
- concat()    将一或多个字符串拼接起来，返回拼接得到的新的字符串
- slice（x，y):截取字符串，第一个x表示开始截取的位置，y表示结束截取的位置,不包含索引为y的
- subStr(x,y):截取字符串，第一个x开始截取的位置，y是表示要截取的个数
- substring() 方法用于提取字符串中介于两个指定下标之间的字符
- toFixed(x): 四舍五入取小数方法，x:表示保留2位小数
- replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。stringObject.replace(regexp/substr,replacement)  1、regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。2、replacement 必需。一个字符串值。规定了替换文本或生成替换文本的函数。
- split() 方法用于把一个字符串分割成字符串数组。  1、参数一：必需。字符串或正则表达式，从该参数指定的地方分割    2、参数二：可选。该参数可指定返回的数组的最大长度
- trim()，会创建一个字符串副本,删除前置以及后缀的所有空格[IE8及一下不支持]
- search()方法,返回字符串中第一个匹配项的索引
>数组操作方法
- join()  将数组转化为字符串方法
- sort()  数组排序   没有参数的时候按字母表排序，arr.sort(function(a,b){return a-b;});     // 升序    arr.sort(function(a,b){return b-a;});     // 降序
- reverse()   数组反转
- push（）  进栈，可放入多个参数，返回插入的长度
- pop()   出栈，返回出栈那个值
- shift()   取出数组的第一个值，返回那个值
- unshift()   向数组的开头添加一个或更多元素，并返回新的长度，unshift() 方法在 IE下 失效！
- slice(start , end);         参数为数组下标，不包括end
- splice(start , length,[item1 , item2]……);     //从start剪切length长度的数组，可选参数为替换原数组剪切的内容
> 浅拷贝和深拷贝区别，描述或者手写深拷贝
-  浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。
- 如果是基本数据类型，直接进行赋值操作，这样就相当于在栈内存中重新开辟了一个新的空间把值传递过去；如果是引用类型的值传递，进行的就是浅拷贝，浅拷贝赋值的只是对象的引用
- 深拷贝： 深拷贝不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上,所以对一个对象的修改并不会影响另一个对象。
> call和apply的用法和区别
- apply：调用一个对象的一个方法，用另一个对象替换当前对象。B.apply(A, arguments);即A对象应用B对象的方法
- call：调用一个对象的一个方法，用另一个对象替换当前对象      B.call(A, args1,args2);即A对象调用B对象的方法
- call 与 apply 的不同点：两者传入的列表形式不一样   call可以传入多个参数； apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入
> js继承的几种方法
- 原型链继承： 让新实例的原型等于父类的实例     特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）  
                                                                        缺点：1、新实例无法向父类构造函数传参。2、继承单一。3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）
- 借用构造函数继承：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
                             特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。2、解决了原型链继承缺点1、2、3。3、可以继承多个构造函数属性（call多个）。4、在子实例中可向父实例传参。
                             缺点：1、只能继承父类构造函数的属性。2、无法实现构造函数的复用。（每次用每次都要重新调用）。3、每个新实例都有父类构造函数的副本，臃肿。
- 原型式继承： 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理
> 事件冒泡及时间捕获
- 事件冒泡：IE提出的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点， 阻止时间冒泡：event.stopPropagation()， return false
- 事件捕获：网景公司提出事件捕获，事件捕获流的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件

### css
>清除浮动的方法
- 使用额外的标签clear:both   原理：在浮动元素下面添加一个空标签，在这个标签中设置clear：both；   优点：简单，浏览器兼容性好；  缺点：增加页面的标签，造成页面混乱；
- 使用overflow属性   原理：父元素定义overflow:hidden，此时，浏览器会自动检查浮动区域的高度； 优点：简单，无需增加新的标签； 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏；
- 使用伪元素:after清除浮动   原理：原理同方法一有点类似，在元素最后定义一个空的内容，然后让该空的内容来清除浮动；优点：无需额外的标签，浏览器兼容性好，是目前用的最多的一种清除浮动的方法之一；
























